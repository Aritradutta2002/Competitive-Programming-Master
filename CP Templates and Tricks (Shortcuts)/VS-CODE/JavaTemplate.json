{
    "CP Template - Ultimate": {
        "prefix": "template",
        "body": [
            "/*",
            " * Author  : Aritra Dutta",
            " * Target  : Codeforces Expert / CSES",
            " * Created : ${CURRENT_DATE}.${CURRENT_MONTH}.${CURRENT_YEAR} ${CURRENT_HOUR}:${CURRENT_MINUTE}",
            " * ",
            " * FAST I/O: BufferedReader + StringTokenizer + PrintWriter",
            " */",
            "import java.io.*;",
            "import java.util.*;",
            "",
            "public class ${TM_FILENAME_BASE} {",
            "    static BufferedReader br;",
            "    static StringTokenizer st;",
            "    static PrintWriter out;",
            "    ",
            "    static final int MOD = 1_000_000_007;",
            "    static final int MOD2 = 998244353;",
            "    static final long INF = (long) 1e18;",
            "    static final Random random = new Random();",
            "    ",
            "    public static void main(String[] args) throws IOException {",
            "        br = new BufferedReader(new InputStreamReader(System.in));",
            "        out = new PrintWriter(new BufferedOutputStream(System.out));",
            "        ",
            "        int t = nextInt();",
            "        while (t-- > 0) {",
            "            solve();",
            "        }",
            "        ",
            "        out.flush();",
            "        out.close();",
            "    }",
            "    ",
            "    static void solve() throws IOException {",
            "        int n = nextInt();",
            "        $0",
            "    }",
            "    ",
            "    // ==================== FAST I/O ====================",
            "    static String next() throws IOException {",
            "        while (st == null || !st.hasMoreTokens())",
            "            st = new StringTokenizer(br.readLine());",
            "        return st.nextToken();",
            "    }",
            "    static int nextInt() throws IOException { return Integer.parseInt(next()); }",
            "    static long nextLong() throws IOException { return Long.parseLong(next()); }",
            "    static double nextDouble() throws IOException { return Double.parseDouble(next()); }",
            "    static int[] nextIntArray(int n) throws IOException {",
            "        int[] arr = new int[n];",
            "        for (int i = 0; i < n; i++) arr[i] = nextInt();",
            "        return arr;",
            "    }",
            "}"
        ],
        "description": "Ultimate Java CP Template - BufferedReader + StringTokenizer + PrintWriter"
    },
    "CP Template Full": {
        "prefix": "cpfull",
        "body": [
            "/*",
            " * Author  : Aritra Dutta",
            " * Target  : Codeforces Expert / CSES",
            " * Created : ${CURRENT_DATE}.${CURRENT_MONTH}.${CURRENT_YEAR} ${CURRENT_HOUR}:${CURRENT_MINUTE}",
            " */",
            "import java.io.*;",
            "import java.util.*;",
            "",
            "public class ${TM_FILENAME_BASE} {",
            "    static BufferedReader br;",
            "    static StringTokenizer st;",
            "    static PrintWriter out;",
            "    ",
            "    static final int MOD = 1_000_000_007;",
            "    static final long INF = (long) 1e18;",
            "    static final Random random = new Random();",
            "    ",
            "    public static void main(String[] args) throws IOException {",
            "        br = new BufferedReader(new InputStreamReader(System.in));",
            "        out = new PrintWriter(new BufferedOutputStream(System.out));",
            "        ",
            "        int t = nextInt();",
            "        while (t-- > 0) solve();",
            "        ",
            "        out.flush();",
            "        out.close();",
            "    }",
            "    ",
            "    static void solve() throws IOException {",
            "        $0",
            "    }",
            "    ",
            "    // ==================== FAST I/O ====================",
            "    static String next() throws IOException {",
            "        while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());",
            "        return st.nextToken();",
            "    }",
            "    static int nextInt() throws IOException { return Integer.parseInt(next()); }",
            "    static long nextLong() throws IOException { return Long.parseLong(next()); }",
            "    static int[] nextIntArray(int n) throws IOException {",
            "        int[] arr = new int[n]; for (int i = 0; i < n; i++) arr[i] = nextInt(); return arr;",
            "    }",
            "    static long[] nextLongArray(int n) throws IOException {",
            "        long[] arr = new long[n]; for (int i = 0; i < n; i++) arr[i] = nextLong(); return arr;",
            "    }",
            "    ",
            "    // ==================== OUTPUT ====================",
            "    static void printArray(int[] arr) {",
            "        StringBuilder sb = new StringBuilder();",
            "        for (int i = 0; i < arr.length; i++) { if (i > 0) sb.append(' '); sb.append(arr[i]); }",
            "        out.println(sb);",
            "    }",
            "    static void printArray(long[] arr) {",
            "        StringBuilder sb = new StringBuilder();",
            "        for (int i = 0; i < arr.length; i++) { if (i > 0) sb.append(' '); sb.append(arr[i]); }",
            "        out.println(sb);",
            "    }",
            "    static void yes() { out.println(\"YES\"); }",
            "    static void no() { out.println(\"NO\"); }",
            "    ",
            "    // ==================== MATH ====================",
            "    static long gcd(long a, long b) { return b == 0 ? a : gcd(b, a % b); }",
            "    static long lcm(long a, long b) { return a / gcd(a, b) * b; }",
            "    static long modPow(long x, long y, long m) {",
            "        long res = 1; x %= m;",
            "        while (y > 0) { if ((y & 1) == 1) res = res * x % m; x = x * x % m; y >>= 1; }",
            "        return res;",
            "    }",
            "    static long modInv(long x, long m) { return modPow(x, m - 2, m); }",
            "    ",
            "    // ==================== SORTING (Anti-hack) ====================",
            "    static void shuffleSort(int[] arr) {",
            "        for (int i = arr.length - 1; i > 0; i--) {",
            "            int j = random.nextInt(i + 1);",
            "            int t = arr[i]; arr[i] = arr[j]; arr[j] = t;",
            "        }",
            "        Arrays.sort(arr);",
            "    }",
            "    static void shuffleSort(long[] arr) {",
            "        for (int i = arr.length - 1; i > 0; i--) {",
            "            int j = random.nextInt(i + 1);",
            "            long t = arr[i]; arr[i] = arr[j]; arr[j] = t;",
            "        }",
            "        Arrays.sort(arr);",
            "    }",
            "}"
        ],
        "description": "Full Java CP Template with utilities"
    },
    "DSU": {
        "prefix": "dsu",
        "body": [
            "static class DSU {",
            "    int[] p, rank;",
            "    int components;",
            "    ",
            "    DSU(int n) {",
            "        p = new int[n]; rank = new int[n]; components = n;",
            "        for (int i = 0; i < n; i++) p[i] = i;",
            "    }",
            "    ",
            "    int find(int x) { return p[x] == x ? x : (p[x] = find(p[x])); }",
            "    ",
            "    boolean unite(int x, int y) {",
            "        x = find(x); y = find(y);",
            "        if (x == y) return false;",
            "        if (rank[x] < rank[y]) { int t = x; x = y; y = t; }",
            "        p[y] = x;",
            "        if (rank[x] == rank[y]) rank[x]++;",
            "        components--;",
            "        return true;",
            "    }",
            "    ",
            "    boolean same(int x, int y) { return find(x) == find(y); }",
            "}"
        ],
        "description": "Disjoint Set Union with path compression and union by rank"
    },
    "Segment Tree": {
        "prefix": "segtree",
        "body": [
            "static class SegTree {",
            "    int n;",
            "    long[] tree;",
            "    ",
            "    SegTree(long[] arr) {",
            "        n = arr.length;",
            "        tree = new long[4 * n];",
            "        build(arr, 1, 0, n - 1);",
            "    }",
            "    ",
            "    void build(long[] arr, int node, int start, int end) {",
            "        if (start == end) { tree[node] = arr[start]; return; }",
            "        int mid = (start + end) / 2;",
            "        build(arr, 2 * node, start, mid);",
            "        build(arr, 2 * node + 1, mid + 1, end);",
            "        tree[node] = tree[2 * node] + tree[2 * node + 1];",
            "    }",
            "    ",
            "    void update(int idx, long val) { update(1, 0, n - 1, idx, val); }",
            "    void update(int node, int start, int end, int idx, long val) {",
            "        if (start == end) { tree[node] = val; return; }",
            "        int mid = (start + end) / 2;",
            "        if (idx <= mid) update(2 * node, start, mid, idx, val);",
            "        else update(2 * node + 1, mid + 1, end, idx, val);",
            "        tree[node] = tree[2 * node] + tree[2 * node + 1];",
            "    }",
            "    ",
            "    long query(int l, int r) { return query(1, 0, n - 1, l, r); }",
            "    long query(int node, int start, int end, int l, int r) {",
            "        if (r < start || end < l) return 0;",
            "        if (l <= start && end <= r) return tree[node];",
            "        int mid = (start + end) / 2;",
            "        return query(2 * node, start, mid, l, r) + query(2 * node + 1, mid + 1, end, l, r);",
            "    }",
            "}"
        ],
        "description": "Segment Tree - Point Update, Range Sum Query"
    },
    "Lazy Segment Tree": {
        "prefix": "lazysegtree",
        "body": [
            "static class LazySegTree {",
            "    int n;",
            "    long[] tree, lazy;",
            "    ",
            "    LazySegTree(int n) { this.n = n; tree = new long[4 * n]; lazy = new long[4 * n]; }",
            "    LazySegTree(long[] arr) { this(arr.length); build(arr, 1, 0, n - 1); }",
            "    ",
            "    void build(long[] arr, int node, int start, int end) {",
            "        if (start == end) { tree[node] = arr[start]; return; }",
            "        int mid = (start + end) / 2;",
            "        build(arr, 2 * node, start, mid);",
            "        build(arr, 2 * node + 1, mid + 1, end);",
            "        tree[node] = tree[2 * node] + tree[2 * node + 1];",
            "    }",
            "    ",
            "    void push(int node, int start, int end) {",
            "        if (lazy[node] != 0) {",
            "            tree[node] += lazy[node] * (end - start + 1);",
            "            if (start != end) { lazy[2 * node] += lazy[node]; lazy[2 * node + 1] += lazy[node]; }",
            "            lazy[node] = 0;",
            "        }",
            "    }",
            "    ",
            "    void updateRange(int l, int r, long val) { updateRange(1, 0, n - 1, l, r, val); }",
            "    void updateRange(int node, int start, int end, int l, int r, long val) {",
            "        push(node, start, end);",
            "        if (r < start || end < l) return;",
            "        if (l <= start && end <= r) { lazy[node] += val; push(node, start, end); return; }",
            "        int mid = (start + end) / 2;",
            "        updateRange(2 * node, start, mid, l, r, val);",
            "        updateRange(2 * node + 1, mid + 1, end, l, r, val);",
            "        tree[node] = tree[2 * node] + tree[2 * node + 1];",
            "    }",
            "    ",
            "    long query(int l, int r) { return query(1, 0, n - 1, l, r); }",
            "    long query(int node, int start, int end, int l, int r) {",
            "        push(node, start, end);",
            "        if (r < start || end < l) return 0;",
            "        if (l <= start && end <= r) return tree[node];",
            "        int mid = (start + end) / 2;",
            "        return query(2 * node, start, mid, l, r) + query(2 * node + 1, mid + 1, end, l, r);",
            "    }",
            "}"
        ],
        "description": "Lazy Segment Tree - Range Update, Range Query"
    },
    "BIT Fenwick Tree": {
        "prefix": "bit",
        "body": [
            "static class BIT {",
            "    int n;",
            "    long[] tree;",
            "    ",
            "    BIT(int n) { this.n = n; tree = new long[n + 1]; }",
            "    ",
            "    void update(int i, long val) { for (; i <= n; i += i & (-i)) tree[i] += val; }",
            "    long query(int i) { long sum = 0; for (; i > 0; i -= i & (-i)) sum += tree[i]; return sum; }",
            "    long query(int l, int r) { return query(r) - query(l - 1); }",
            "}"
        ],
        "description": "Binary Indexed Tree (Fenwick Tree)"
    },
    "BFS": {
        "prefix": "bfs",
        "body": [
            "static int[] bfs(int start, List<List<Integer>> adj) {",
            "    int n = adj.size();",
            "    int[] dist = new int[n];",
            "    Arrays.fill(dist, -1);",
            "    ArrayDeque<Integer> q = new ArrayDeque<>();",
            "    q.add(start);",
            "    dist[start] = 0;",
            "    while (!q.isEmpty()) {",
            "        int u = q.poll();",
            "        for (int v : adj.get(u)) {",
            "            if (dist[v] == -1) {",
            "                dist[v] = dist[u] + 1;",
            "                q.add(v);",
            "            }",
            "        }",
            "    }",
            "    return dist;",
            "}"
        ],
        "description": "BFS - Returns distance array"
    },
    "DFS Iterative": {
        "prefix": "dfs",
        "body": [
            "static void dfs(int start, List<List<Integer>> adj, boolean[] visited) {",
            "    ArrayDeque<Integer> stack = new ArrayDeque<>();",
            "    stack.push(start);",
            "    while (!stack.isEmpty()) {",
            "        int u = stack.pop();",
            "        if (visited[u]) continue;",
            "        visited[u] = true;",
            "        // Process node u here",
            "        for (int v : adj.get(u)) {",
            "            if (!visited[v]) stack.push(v);",
            "        }",
            "    }",
            "}"
        ],
        "description": "DFS Iterative - No stack overflow"
    },
    "Dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "static long[] dijkstra(int src, List<List<long[]>> adj) {",
            "    int n = adj.size();",
            "    long[] dist = new long[n];",
            "    Arrays.fill(dist, Long.MAX_VALUE);",
            "    dist[src] = 0;",
            "    PriorityQueue<long[]> pq = new PriorityQueue<>(Comparator.comparingLong(a -> a[1]));",
            "    pq.add(new long[]{src, 0});",
            "    while (!pq.isEmpty()) {",
            "        long[] node = pq.poll();",
            "        int u = (int) node[0];",
            "        long d = node[1];",
            "        if (d > dist[u]) continue;",
            "        for (long[] edge : adj.get(u)) {",
            "            int v = (int) edge[0];",
            "            long w = edge[1];",
            "            if (dist[u] + w < dist[v]) {",
            "                dist[v] = dist[u] + w;",
            "                pq.add(new long[]{v, dist[v]});",
            "            }",
            "        }",
            "    }",
            "    return dist;",
            "}"
        ],
        "description": "Dijkstra's Algorithm - Shortest Path"
    },
    "Bellman Ford": {
        "prefix": "bellmanford",
        "body": [
            "static long[] bellmanFord(int n, int src, List<int[]> edges) {",
            "    long[] dist = new long[n];",
            "    Arrays.fill(dist, Long.MAX_VALUE);",
            "    dist[src] = 0;",
            "    for (int i = 0; i < n - 1; i++) {",
            "        for (int[] e : edges) {",
            "            int u = e[0], v = e[1], w = e[2];",
            "            if (dist[u] != Long.MAX_VALUE && dist[u] + w < dist[v]) {",
            "                dist[v] = dist[u] + w;",
            "            }",
            "        }",
            "    }",
            "    // Check negative cycle",
            "    for (int[] e : edges) {",
            "        if (dist[e[0]] != Long.MAX_VALUE && dist[e[0]] + e[2] < dist[e[1]]) {",
            "            return null; // Negative cycle exists",
            "        }",
            "    }",
            "    return dist;",
            "}"
        ],
        "description": "Bellman-Ford Algorithm"
    },
    "Floyd Warshall": {
        "prefix": "floydwarshall",
        "body": [
            "static long[][] floydWarshall(long[][] dist) {",
            "    int n = dist.length;",
            "    for (int k = 0; k < n; k++) {",
            "        for (int i = 0; i < n; i++) {",
            "            for (int j = 0; j < n; j++) {",
            "                if (dist[i][k] != Long.MAX_VALUE && dist[k][j] != Long.MAX_VALUE) {",
            "                    dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);",
            "                }",
            "            }",
            "        }",
            "    }",
            "    return dist;",
            "}"
        ],
        "description": "Floyd-Warshall All Pairs Shortest Path"
    },
    "Topological Sort": {
        "prefix": "toposort",
        "body": [
            "static int[] toposort(List<List<Integer>> adj) {",
            "    int n = adj.size();",
            "    int[] indeg = new int[n];",
            "    for (int u = 0; u < n; u++) for (int v : adj.get(u)) indeg[v]++;",
            "    ArrayDeque<Integer> q = new ArrayDeque<>();",
            "    for (int i = 0; i < n; i++) if (indeg[i] == 0) q.add(i);",
            "    int[] order = new int[n];",
            "    int idx = 0;",
            "    while (!q.isEmpty()) {",
            "        int u = q.poll();",
            "        order[idx++] = u;",
            "        for (int v : adj.get(u)) if (--indeg[v] == 0) q.add(v);",
            "    }",
            "    return idx == n ? order : null; // null if cycle",
            "}"
        ],
        "description": "Topological Sort (Kahn's Algorithm)"
    },
    "LCA Binary Lifting": {
        "prefix": "lca",
        "body": [
            "static class LCA {",
            "    int n, LOG;",
            "    int[][] up;",
            "    int[] depth;",
            "    ",
            "    LCA(List<List<Integer>> adj, int root) {",
            "        n = adj.size();",
            "        LOG = 32 - Integer.numberOfLeadingZeros(n);",
            "        up = new int[n][LOG];",
            "        depth = new int[n];",
            "        for (int[] row : up) Arrays.fill(row, -1);",
            "        ArrayDeque<int[]> q = new ArrayDeque<>();",
            "        q.add(new int[]{root, -1});",
            "        while (!q.isEmpty()) {",
            "            int[] curr = q.poll();",
            "            int u = curr[0], p = curr[1];",
            "            up[u][0] = p;",
            "            for (int i = 1; i < LOG; i++)",
            "                if (up[u][i-1] != -1) up[u][i] = up[up[u][i-1]][i-1];",
            "            for (int v : adj.get(u)) {",
            "                if (v != p) { depth[v] = depth[u] + 1; q.add(new int[]{v, u}); }",
            "            }",
            "        }",
            "    }",
            "    ",
            "    int lca(int u, int v) {",
            "        if (depth[u] < depth[v]) { int t = u; u = v; v = t; }",
            "        int diff = depth[u] - depth[v];",
            "        for (int i = 0; i < LOG; i++) if (((diff >> i) & 1) == 1) u = up[u][i];",
            "        if (u == v) return u;",
            "        for (int i = LOG - 1; i >= 0; i--)",
            "            if (up[u][i] != up[v][i]) { u = up[u][i]; v = up[v][i]; }",
            "        return up[u][0];",
            "    }",
            "    ",
            "    int dist(int u, int v) { return depth[u] + depth[v] - 2 * depth[lca(u, v)]; }",
            "}"
        ],
        "description": "LCA with Binary Lifting"
    },
    "Sieve": {
        "prefix": "sieve",
        "body": [
            "static boolean[] sieve(int n) {",
            "    boolean[] isPrime = new boolean[n + 1];",
            "    Arrays.fill(isPrime, true);",
            "    isPrime[0] = isPrime[1] = false;",
            "    for (int i = 2; i * i <= n; i++) {",
            "        if (isPrime[i]) {",
            "            for (int j = i * i; j <= n; j += i) isPrime[j] = false;",
            "        }",
            "    }",
            "    return isPrime;",
            "}"
        ],
        "description": "Sieve of Eratosthenes"
    },
    "nCr Factorials": {
        "prefix": "ncr",
        "body": [
            "static final int MAXN = 2_000_001;",
            "static long[] fact = new long[MAXN];",
            "static long[] invFact = new long[MAXN];",
            "",
            "static void precomputeFactorials() {",
            "    fact[0] = 1;",
            "    for (int i = 1; i < MAXN; i++) fact[i] = fact[i - 1] * i % MOD;",
            "    invFact[MAXN - 1] = modPow(fact[MAXN - 1], MOD - 2, MOD);",
            "    for (int i = MAXN - 2; i >= 0; i--) invFact[i] = invFact[i + 1] * (i + 1) % MOD;",
            "}",
            "",
            "static long nCr(int n, int r) {",
            "    if (r < 0 || r > n) return 0;",
            "    return fact[n] * invFact[r] % MOD * invFact[n - r] % MOD;",
            "}",
            "",
            "static long modPow(long x, long y, long m) {",
            "    long res = 1; x %= m;",
            "    while (y > 0) { if ((y & 1) == 1) res = res * x % m; x = x * x % m; y >>= 1; }",
            "    return res;",
            "}"
        ],
        "description": "nCr with precomputed factorials"
    },
    "Matrix Exponentiation": {
        "prefix": "matpow",
        "body": [
            "static long[][] matMul(long[][] A, long[][] B, long mod) {",
            "    int n = A.length;",
            "    long[][] C = new long[n][n];",
            "    for (int i = 0; i < n; i++)",
            "        for (int k = 0; k < n; k++)",
            "            for (int j = 0; j < n; j++)",
            "                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % mod;",
            "    return C;",
            "}",
            "",
            "static long[][] matPow(long[][] A, long p, long mod) {",
            "    int n = A.length;",
            "    long[][] res = new long[n][n];",
            "    for (int i = 0; i < n; i++) res[i][i] = 1;",
            "    while (p > 0) {",
            "        if ((p & 1) == 1) res = matMul(res, A, mod);",
            "        A = matMul(A, A, mod);",
            "        p >>= 1;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Matrix Exponentiation"
    },
    "Binary Exponentiation": {
        "prefix": "binpow",
        "body": [
            "static long modPow(long x, long y, long m) {",
            "    long res = 1; x %= m;",
            "    while (y > 0) {",
            "        if ((y & 1) == 1) res = res * x % m;",
            "        x = x * x % m;",
            "        y >>= 1;",
            "    }",
            "    return res;",
            "}",
            "static long modInv(long x, long m) { return modPow(x, m - 2, m); }"
        ],
        "description": "Binary Exponentiation with Modular Inverse"
    },
    "KMP": {
        "prefix": "kmp",
        "body": [
            "static int[] prefixFunction(String s) {",
            "    int n = s.length();",
            "    int[] pi = new int[n];",
            "    for (int i = 1; i < n; i++) {",
            "        int j = pi[i - 1];",
            "        while (j > 0 && s.charAt(i) != s.charAt(j)) j = pi[j - 1];",
            "        if (s.charAt(i) == s.charAt(j)) j++;",
            "        pi[i] = j;",
            "    }",
            "    return pi;",
            "}",
            "",
            "static List<Integer> kmpSearch(String text, String pattern) {",
            "    String combined = pattern + \"#\" + text;",
            "    int[] pi = prefixFunction(combined);",
            "    List<Integer> matches = new ArrayList<>();",
            "    int plen = pattern.length();",
            "    for (int i = plen + 1; i < combined.length(); i++)",
            "        if (pi[i] == plen) matches.add(i - 2 * plen);",
            "    return matches;",
            "}"
        ],
        "description": "KMP Pattern Matching"
    },
    "Z Function": {
        "prefix": "zfunction",
        "body": [
            "static int[] zFunction(String s) {",
            "    int n = s.length();",
            "    int[] z = new int[n];",
            "    int l = 0, r = 0;",
            "    for (int i = 1; i < n; i++) {",
            "        if (i < r) z[i] = Math.min(r - i, z[i - l]);",
            "        while (i + z[i] < n && s.charAt(z[i]) == s.charAt(i + z[i])) z[i]++;",
            "        if (i + z[i] > r) { l = i; r = i + z[i]; }",
            "    }",
            "    return z;",
            "}"
        ],
        "description": "Z-Function for pattern matching"
    },
    "String Hash": {
        "prefix": "strhash",
        "body": [
            "static class StringHash {",
            "    long[] hash, pw;",
            "    long base = 31, mod = 1_000_000_007;",
            "    ",
            "    StringHash(String s) {",
            "        int n = s.length();",
            "        hash = new long[n + 1];",
            "        pw = new long[n + 1];",
            "        pw[0] = 1;",
            "        for (int i = 0; i < n; i++) {",
            "            hash[i + 1] = (hash[i] * base + s.charAt(i) - 'a' + 1) % mod;",
            "            pw[i + 1] = pw[i] * base % mod;",
            "        }",
            "    }",
            "    ",
            "    long getHash(int l, int r) { // [l, r] inclusive",
            "        return (hash[r + 1] - hash[l] * pw[r - l + 1] % mod + mod) % mod;",
            "    }",
            "}"
        ],
        "description": "String Hashing for substring comparison"
    },
    "Trie": {
        "prefix": "trie",
        "body": [
            "static class Trie {",
            "    int[][] ch;",
            "    int[] cnt;",
            "    int nodes = 1;",
            "    ",
            "    Trie(int maxNodes) { ch = new int[maxNodes][26]; cnt = new int[maxNodes]; }",
            "    ",
            "    void insert(String s) {",
            "        int cur = 0;",
            "        for (char c : s.toCharArray()) {",
            "            int idx = c - 'a';",
            "            if (ch[cur][idx] == 0) ch[cur][idx] = nodes++;",
            "            cur = ch[cur][idx];",
            "        }",
            "        cnt[cur]++;",
            "    }",
            "    ",
            "    int count(String s) {",
            "        int cur = 0;",
            "        for (char c : s.toCharArray()) {",
            "            int idx = c - 'a';",
            "            if (ch[cur][idx] == 0) return 0;",
            "            cur = ch[cur][idx];",
            "        }",
            "        return cnt[cur];",
            "    }",
            "}"
        ],
        "description": "Trie Data Structure"
    },
    "Multiset": {
        "prefix": "multiset",
        "body": [
            "static class Multiset {",
            "    TreeMap<Integer, Integer> map = new TreeMap<>();",
            "    int size = 0;",
            "    ",
            "    void add(int x) { map.merge(x, 1, Integer::sum); size++; }",
            "    void remove(int x) {",
            "        if (map.containsKey(x)) {",
            "            if (map.get(x) == 1) map.remove(x);",
            "            else map.merge(x, -1, Integer::sum);",
            "            size--;",
            "        }",
            "    }",
            "    int count(int x) { return map.getOrDefault(x, 0); }",
            "    int first() { return map.firstKey(); }",
            "    int last() { return map.lastKey(); }",
            "    Integer lower(int x) { return map.lowerKey(x); }",
            "    Integer higher(int x) { return map.higherKey(x); }",
            "    Integer floor(int x) { return map.floorKey(x); }",
            "    Integer ceiling(int x) { return map.ceilingKey(x); }",
            "    int size() { return size; }",
            "}"
        ],
        "description": "Multiset using TreeMap"
    },
    "Pair": {
        "prefix": "pair",
        "body": [
            "static class Pair implements Comparable<Pair> {",
            "    int first, second;",
            "    Pair(int f, int s) { first = f; second = s; }",
            "    public int compareTo(Pair o) {",
            "        if (first != o.first) return Integer.compare(first, o.first);",
            "        return Integer.compare(second, o.second);",
            "    }",
            "    public boolean equals(Object o) {",
            "        if (!(o instanceof Pair)) return false;",
            "        Pair p = (Pair) o;",
            "        return first == p.first && second == p.second;",
            "    }",
            "    public int hashCode() { return 31 * first + second; }",
            "}"
        ],
        "description": "Pair class with Comparable"
    },
    "Shuffle Sort": {
        "prefix": "shufflesort",
        "body": [
            "static void shuffleSort(int[] arr) {",
            "    Random random = new Random();",
            "    for (int i = arr.length - 1; i > 0; i--) {",
            "        int j = random.nextInt(i + 1);",
            "        int t = arr[i]; arr[i] = arr[j]; arr[j] = t;",
            "    }",
            "    Arrays.sort(arr);",
            "}",
            "static void shuffleSort(long[] arr) {",
            "    Random random = new Random();",
            "    for (int i = arr.length - 1; i > 0; i--) {",
            "        int j = random.nextInt(i + 1);",
            "        long t = arr[i]; arr[i] = arr[j]; arr[j] = t;",
            "    }",
            "    Arrays.sort(arr);",
            "}"
        ],
        "description": "Shuffle before sort to avoid O(nÂ²) anti-hack"
    },
    "GCD LCM": {
        "prefix": "gcdlcm",
        "body": [
            "static long gcd(long a, long b) { return b == 0 ? a : gcd(b, a % b); }",
            "static long lcm(long a, long b) { return a / gcd(a, b) * b; }"
        ],
        "description": "GCD and LCM"
    },
    "Lower Upper Bound": {
        "prefix": "bounds",
        "body": [
            "// Returns first index where arr[i] >= x",
            "static int lowerBound(int[] arr, int x) {",
            "    int lo = 0, hi = arr.length;",
            "    while (lo < hi) {",
            "        int mid = lo + (hi - lo) / 2;",
            "        if (arr[mid] < x) lo = mid + 1;",
            "        else hi = mid;",
            "    }",
            "    return lo;",
            "}",
            "// Returns first index where arr[i] > x",
            "static int upperBound(int[] arr, int x) {",
            "    int lo = 0, hi = arr.length;",
            "    while (lo < hi) {",
            "        int mid = lo + (hi - lo) / 2;",
            "        if (arr[mid] <= x) lo = mid + 1;",
            "        else hi = mid;",
            "    }",
            "    return lo;",
            "}"
        ],
        "description": "Lower and Upper Bound"
    },
    "Fast IO Class": {
        "prefix": "fastio",
        "body": [
            "static class FastIO extends PrintWriter {",
            "    private InputStream stream;",
            "    private byte[] buf = new byte[1 << 16];",
            "    private int curChar, numChars;",
            "    ",
            "    public FastIO() { this(System.in, System.out); }",
            "    public FastIO(InputStream i, OutputStream o) { super(o); stream = i; }",
            "    ",
            "    private int nextByte() {",
            "        if (numChars == -1) throw new InputMismatchException();",
            "        if (curChar >= numChars) {",
            "            curChar = 0;",
            "            try { numChars = stream.read(buf); }",
            "            catch (IOException e) { throw new InputMismatchException(); }",
            "            if (numChars == -1) return -1;",
            "        }",
            "        return buf[curChar++];",
            "    }",
            "    ",
            "    public String next() {",
            "        int c; do { c = nextByte(); } while (c <= ' ');",
            "        StringBuilder res = new StringBuilder();",
            "        do { res.appendCodePoint(c); c = nextByte(); } while (c > ' ');",
            "        return res.toString();",
            "    }",
            "    ",
            "    public int nextInt() {",
            "        int c; do { c = nextByte(); } while (c <= ' ');",
            "        int sgn = 1;",
            "        if (c == '-') { sgn = -1; c = nextByte(); }",
            "        int res = 0;",
            "        do {",
            "            if (c < '0' || c > '9') throw new InputMismatchException();",
            "            res = 10 * res + c - '0';",
            "            c = nextByte();",
            "        } while (c > ' ');",
            "        return res * sgn;",
            "    }",
            "    ",
            "    public long nextLong() {",
            "        int c; do { c = nextByte(); } while (c <= ' ');",
            "        long sgn = 1;",
            "        if (c == '-') { sgn = -1; c = nextByte(); }",
            "        long res = 0;",
            "        do {",
            "            if (c < '0' || c > '9') throw new InputMismatchException();",
            "            res = 10 * res + c - '0';",
            "            c = nextByte();",
            "        } while (c > ' ');",
            "        return res * sgn;",
            "    }",
            "    ",
            "    public double nextDouble() { return Double.parseDouble(next()); }",
            "}"
        ],
        "description": "Ultra Fast IO Class"
    },
    "Graph Create": {
        "prefix": "graphcreate",
        "body": [
            "List<List<Integer>> adj = new ArrayList<>();",
            "for (int i = 0; i < n; i++) adj.add(new ArrayList<>());",
            "for (int i = 0; i < m; i++) {",
            "    int u = nextInt() - 1, v = nextInt() - 1;",
            "    adj.get(u).add(v);",
            "    adj.get(v).add(u); // Remove for directed",
            "}"
        ],
        "description": "Create adjacency list graph"
    },
    "Weighted Graph Create": {
        "prefix": "wgraphcreate",
        "body": [
            "List<List<long[]>> adj = new ArrayList<>();",
            "for (int i = 0; i < n; i++) adj.add(new ArrayList<>());",
            "for (int i = 0; i < m; i++) {",
            "    int u = nextInt() - 1, v = nextInt() - 1;",
            "    long w = nextLong();",
            "    adj.get(u).add(new long[]{v, w});",
            "    adj.get(v).add(new long[]{u, w}); // Remove for directed",
            "}"
        ],
        "description": "Create weighted adjacency list graph"
    },
    "For Loop i 0 to n": {
        "prefix": "fori0",
        "body": ["for (int i = 0; i < ${1:n}; i++) {", "\t$0", "}"],
        "description": "For loop i from 0 to n-1"
    },
    "For Loop i 1 to n": {
        "prefix": "fori1",
        "body": ["for (int i = 1; i <= ${1:n}; i++) {", "\t$0", "}"],
        "description": "For loop i from 1 to n"
    },
    "For Loop j 0 to n": {
        "prefix": "forj0",
        "body": ["for (int j = 0; j < ${1:n}; j++) {", "\t$0", "}"],
        "description": "For loop j from 0 to n-1"
    },
    "For Loop j 1 to n": {
        "prefix": "forj1",
        "body": ["for (int j = 1; j <= ${1:n}; j++) {", "\t$0", "}"],
        "description": "For loop j from 1 to n"
    },
    "For Loop k 0 to n": {
        "prefix": "fork0",
        "body": ["for (int k = 0; k < ${1:n}; k++) {", "\t$0", "}"],
        "description": "For loop k from 0 to n-1"
    },
    "Reverse For Loop i": {
        "prefix": "rfori",
        "body": ["for (int i = ${1:n} - 1; i >= 0; i--) {", "\t$0", "}"],
        "description": "Reverse for loop i from n-1 to 0"
    },
    "Reverse For Loop j": {
        "prefix": "rforj",
        "body": ["for (int j = ${1:n} - 1; j >= 0; j--) {", "\t$0", "}"],
        "description": "Reverse for loop j from n-1 to 0"
    },
    "Print Array": {
        "prefix": "printarr",
        "body": [
            "static void printArray(int[] arr) {",
            "    StringBuilder sb = new StringBuilder();",
            "    for (int i = 0; i < arr.length; i++) {",
            "        if (i > 0) sb.append(' ');",
            "        sb.append(arr[i]);",
            "    }",
            "    out.println(sb);",
            "}"
        ],
        "description": "Print array with StringBuilder"
    },
    "Yes No": {
        "prefix": "yesno",
        "body": [
            "static void yes() { out.println(\"YES\"); }",
            "static void no() { out.println(\"NO\"); }"
        ],
        "description": "Yes/No helper functions"
    },
    "Dinic Max Flow": {
        "prefix": "dinic",
        "body": [
            "static class Dinic {",
            "    static class Edge { int to, rev, cap, flow; Edge(int t, int r, int c) { to = t; rev = r; cap = c; } }",
            "    List<Edge>[] g;",
            "    int[] level, ptr;",
            "    int n;",
            "    ",
            "    Dinic(int n) { this.n = n; g = new ArrayList[n]; for (int i = 0; i < n; i++) g[i] = new ArrayList<>(); }",
            "    void addEdge(int u, int v, int cap) {",
            "        g[u].add(new Edge(v, g[v].size(), cap));",
            "        g[v].add(new Edge(u, g[u].size() - 1, 0));",
            "    }",
            "    boolean bfs(int s, int t) {",
            "        level = new int[n]; Arrays.fill(level, -1); level[s] = 0;",
            "        ArrayDeque<Integer> q = new ArrayDeque<>(); q.add(s);",
            "        while (!q.isEmpty()) {",
            "            int u = q.poll();",
            "            for (Edge e : g[u]) if (level[e.to] == -1 && e.flow < e.cap) { level[e.to] = level[u] + 1; q.add(e.to); }",
            "        }",
            "        return level[t] != -1;",
            "    }",
            "    int dfs(int u, int t, int flow) {",
            "        if (u == t) return flow;",
            "        for (; ptr[u] < g[u].size(); ptr[u]++) {",
            "            Edge e = g[u].get(ptr[u]);",
            "            if (level[e.to] == level[u] + 1 && e.flow < e.cap) {",
            "                int pushed = dfs(e.to, t, Math.min(flow, e.cap - e.flow));",
            "                if (pushed > 0) { e.flow += pushed; g[e.to].get(e.rev).flow -= pushed; return pushed; }",
            "            }",
            "        }",
            "        return 0;",
            "    }",
            "    int maxFlow(int s, int t) {",
            "        int flow = 0;",
            "        while (bfs(s, t)) { ptr = new int[n]; int pushed; while ((pushed = dfs(s, t, Integer.MAX_VALUE)) > 0) flow += pushed; }",
            "        return flow;",
            "    }",
            "}"
        ],
        "description": "Dinic's Max Flow Algorithm"
    },
    "Kosaraju SCC": {
        "prefix": "kosaraju",
        "body": [
            "static class Kosaraju {",
            "    List<Integer>[] g, rg;",
            "    boolean[] vis;",
            "    ArrayDeque<Integer> order;",
            "    List<List<Integer>> sccs;",
            "    ",
            "    Kosaraju(int n) {",
            "        g = new ArrayList[n]; rg = new ArrayList[n];",
            "        for (int i = 0; i < n; i++) { g[i] = new ArrayList<>(); rg[i] = new ArrayList<>(); }",
            "    }",
            "    void addEdge(int u, int v) { g[u].add(v); rg[v].add(u); }",
            "    void dfs1(int u) { vis[u] = true; for (int v : g[u]) if (!vis[v]) dfs1(v); order.push(u); }",
            "    void dfs2(int u, List<Integer> comp) { vis[u] = true; comp.add(u); for (int v : rg[u]) if (!vis[v]) dfs2(v, comp); }",
            "    List<List<Integer>> getSCCs() {",
            "        int n = g.length;",
            "        vis = new boolean[n]; order = new ArrayDeque<>();",
            "        for (int i = 0; i < n; i++) if (!vis[i]) dfs1(i);",
            "        Arrays.fill(vis, false);",
            "        sccs = new ArrayList<>();",
            "        while (!order.isEmpty()) {",
            "            int u = order.pop();",
            "            if (!vis[u]) { List<Integer> comp = new ArrayList<>(); dfs2(u, comp); sccs.add(comp); }",
            "        }",
            "        return sccs;",
            "    }",
            "}"
        ],
        "description": "Kosaraju's SCC Algorithm"
    },
    "Convex Hull Trick": {
        "prefix": "cht",
        "body": [
            "static class CHT {",
            "    ArrayDeque<long[]> dq = new ArrayDeque<>(); // {m, b}",
            "    boolean bad(long[] l1, long[] l2, long[] l3) {",
            "        return (l3[1] - l1[1]) * (l1[0] - l2[0]) <= (l2[1] - l1[1]) * (l1[0] - l3[0]);",
            "    }",
            "    void addLine(long m, long b) {",
            "        long[] line = {m, b};",
            "        while (dq.size() >= 2 && bad(dq.peekLast(), dq.pollLast(), line)) {}",
            "        dq.addLast(line);",
            "    }",
            "    long query(long x) {",
            "        while (dq.size() >= 2 && eval(dq.peekFirst(), x) >= eval(dq.pollFirst(), x)) {}",
            "        return eval(dq.peekFirst(), x);",
            "    }",
            "    long eval(long[] line, long x) { return line[0] * x + line[1]; }",
            "}"
        ],
        "description": "Convex Hull Trick for DP optimization"
    },
    "Sparse Table": {
        "prefix": "sparsetable",
        "body": [
            "static class SparseTable {",
            "    int[][] table;",
            "    int[] log;",
            "    ",
            "    SparseTable(int[] arr) {",
            "        int n = arr.length;",
            "        int LOG = 32 - Integer.numberOfLeadingZeros(n);",
            "        log = new int[n + 1];",
            "        for (int i = 2; i <= n; i++) log[i] = log[i / 2] + 1;",
            "        table = new int[LOG][n];",
            "        table[0] = arr.clone();",
            "        for (int j = 1; j < LOG; j++)",
            "            for (int i = 0; i + (1 << j) <= n; i++)",
            "                table[j][i] = Math.min(table[j-1][i], table[j-1][i + (1 << (j-1))]);",
            "    }",
            "    ",
            "    int query(int l, int r) {",
            "        int j = log[r - l + 1];",
            "        return Math.min(table[j][l], table[j][r - (1 << j) + 1]);",
            "    }",
            "}"
        ],
        "description": "Sparse Table for O(1) RMQ"
    },
    "Interactive Template": {
        "prefix": "interactive",
        "body": [
            "// For interactive problems - NO BufferedOutputStream!",
            "static PrintWriter out = new PrintWriter(System.out);",
            "",
            "static int query(int x) throws IOException {",
            "    out.println(\"? \" + x);",
            "    out.flush(); // CRITICAL!",
            "    return nextInt();",
            "}",
            "",
            "static void answer(int x) {",
            "    out.println(\"! \" + x);",
            "    out.flush();",
            "}"
        ],
        "description": "Interactive problem template"
    },
    "Count Inversions": {
        "prefix": "inversions",
        "body": [
            "static long countInversions(int[] arr) {",
            "    int n = arr.length;",
            "    int[] sorted = arr.clone();",
            "    Arrays.sort(sorted);",
            "    Map<Integer, Integer> compress = new HashMap<>();",
            "    int rank = 0;",
            "    for (int x : sorted) if (!compress.containsKey(x)) compress.put(x, ++rank);",
            "    ",
            "    long[] bit = new long[rank + 1];",
            "    long inv = 0;",
            "    for (int i = n - 1; i >= 0; i--) {",
            "        int pos = compress.get(arr[i]);",
            "        for (int j = pos - 1; j > 0; j -= j & (-j)) inv += bit[j];",
            "        for (int j = pos; j <= rank; j += j & (-j)) bit[j]++;",
            "    }",
            "    return inv;",
            "}"
        ],
        "description": "Count inversions using BIT"
    },
    "LIS": {
        "prefix": "lis",
        "body": [
            "static int lis(int[] arr) {",
            "    List<Integer> dp = new ArrayList<>();",
            "    for (int x : arr) {",
            "        int pos = Collections.binarySearch(dp, x);",
            "        if (pos < 0) pos = -(pos + 1);",
            "        if (pos == dp.size()) dp.add(x);",
            "        else dp.set(pos, x);",
            "    }",
            "    return dp.size();",
            "}"
        ],
        "description": "Longest Increasing Subsequence O(n log n)"
    },
    "Coordinate Compression": {
        "prefix": "compress",
        "body": [
            "static int[] compress(int[] arr) {",
            "    int[] sorted = arr.clone();",
            "    Arrays.sort(sorted);",
            "    Map<Integer, Integer> map = new HashMap<>();",
            "    int rank = 0;",
            "    for (int x : sorted) if (!map.containsKey(x)) map.put(x, rank++);",
            "    int[] result = new int[arr.length];",
            "    for (int i = 0; i < arr.length; i++) result[i] = map.get(arr[i]);",
            "    return result;",
            "}"
        ],
        "description": "Coordinate Compression"
    },
    "Prefix Sum 2D": {
        "prefix": "prefix2d",
        "body": [
            "static long[][] buildPrefix2D(int[][] grid) {",
            "    int n = grid.length, m = grid[0].length;",
            "    long[][] prefix = new long[n + 1][m + 1];",
            "    for (int i = 1; i <= n; i++)",
            "        for (int j = 1; j <= m; j++)",
            "            prefix[i][j] = grid[i-1][j-1] + prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1];",
            "    return prefix;",
            "}",
            "// Query sum of rectangle [(r1,c1), (r2,c2)] (0-indexed)",
            "static long query2D(long[][] prefix, int r1, int c1, int r2, int c2) {",
            "    return prefix[r2+1][c2+1] - prefix[r1][c2+1] - prefix[r2+1][c1] + prefix[r1][c1];",
            "}"
        ],
        "description": "2D Prefix Sum"
    }
}
