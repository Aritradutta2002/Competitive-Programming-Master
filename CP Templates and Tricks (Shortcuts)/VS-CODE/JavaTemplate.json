{
    "template": {
        "prefix": "template",
        "body": [
            "/*",
            "*\tAuthor: Aritra Dutta",
            "*\tCreated: ${CURRENT_DATE}.${CURRENT_MONTH}.${CURRENT_YEAR} ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND} (GMT+5:30)",
            "*/",
            "import static java.lang.Math.max;",
            "import static java.lang.Math.min;",
            "import static java.lang.Math.abs;",
            "import static java.lang.System.out;",
            "import java.io.*;",
            "import java.util.*;",
            "import java.math.*;",
            "",
            "public class ${1} {",
            "",
            "    public static final Random random = new Random();",
            "    public static final int mod = 1_000_000_007;",
            "",
            "    public static void main(String[] args) throws Exception {",
            "        FastScanner fs = new FastScanner();",
            "        PrintWriter out = new PrintWriter(System.out);",
            "        int T = fs.nextInt();",
            "        while (T-- > 0) {",
            "            int n = fs.nextInt();",
            "            System.out.println(\"hello world\");",
            "        }",
            "        out.close();",
            "    }",
            "",
            "    /* ----------- BFS (Recursive) -------------- */",
            "    static void bfsRecursive(int start, List<List<Integer>> adj) {",
            "        Queue<Integer> q = new ArrayDeque<>();",
            "        boolean[] visited = new boolean[adj.size()];",
            "        q.add(start);",
            "        visited[start] = true;",
            "        while (!q.isEmpty()) {",
            "            int u = q.poll();",
            "            out.print(u + \" \"); // Process node u",
            "            for (int v : adj.get(u)) {",
            "                if (!visited[v]) {",
            "                    visited[v] = true;",
            "                    q.add(v);",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    /* ------ Optimized BFS ------ */",
            "    static void bfsOptimized(int start, List<List<Integer>> adj) {",
            "        ArrayDeque<Integer> q = new ArrayDeque<>();",
            "        BitSet visited = new BitSet(adj.size());",
            "        q.add(start);",
            "        visited.set(start);",
            "        while (!q.isEmpty()) {",
            "            int u = q.poll();",
            "            // Process node u here (if needed)",
            "            for (int v : adj.get(u)) {",
            "                if (!visited.get(v)) {",
            "                    visited.set(v);",
            "                    q.add(v);",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    /* ----- DFS (Recursive) ------- */",
            "    static void dfsRecursive(int u, List<List<Integer>> adj, boolean[] visited) {",
            "        visited[u] = true;",
            "        out.print(u + \" \"); // Process node u",
            "        for (int v : adj.get(u)) {",
            "            if (!visited[v]) {",
            "                dfsRecursive(v, adj, visited);",
            "            }",
            "        }",
            "    }",
            "",
            "    /* --------- Optimized DFS (Iterative) no recursion overhead ------- */",
            "    static void dfsOptimized(int start, List<List<Integer>> adj) {",
            "        ArrayDeque<Integer> stack = new ArrayDeque<>();",
            "        BitSet visited = new BitSet(adj.size());",
            "        stack.push(start);",
            "        visited.set(start);",
            "        while (!stack.isEmpty()) {",
            "            int u = stack.pop();",
            "            // Process node u here (if needed)",
            "            for (int v : adj.get(u)) {",
            "                if (!visited.get(v)) {",
            "                    visited.set(v);",
            "                    stack.push(v);",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    /* -------- Graph Input Helper ----------- */",
            "    static List<Integer>[] createGraph(int nodes, int edges, FastScanner fs) {",
            "        List<Integer>[] adj = new ArrayList[nodes];",
            "        for (int i = 0; i < nodes; i++) adj[i] = new ArrayList<>();",
            "        for (int i = 0; i < edges; i++) {",
            "            int u = fs.nextInt() - 1, v = fs.nextInt() - 1;",
            "            adj[u].add(v);",
            "            adj[v].add(u); // Remove if directed graph",
            "        }",
            "        return adj;",
            "    }",
            "",
            "    /*------ Dijkstra's Algorithm -----*/",
            "    static int[] dijkstra(int src, List<int[]>[] adj) {",
            "        int n = adj.length;",
            "        int[] dist = new int[n];",
            "        Arrays.fill(dist, Integer.MAX_VALUE);",
            "        dist[src] = 0;",
            "        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));",
            "        pq.add(new int[]{src, 0});",
            "        while (!pq.isEmpty()) {",
            "            int[] node = pq.poll();",
            "            int u = node[0], d = node[1];",
            "            if (d > dist[u]) continue;",
            "            for (int[] edge : adj[u]) {",
            "                int v = edge[0], weight = edge[1];",
            "                if (dist[u] + weight < dist[v]) {",
            "                    dist[v] = dist[u] + weight;",
            "                    pq.add(new int[]{v, dist[v]});",
            "                }",
            "            }",
            "        }",
            "        return dist;",
            "    }",
            "",
            "    /* ============================== Math Utilities ======================================= */",
            "    public static boolean isPrime(long n) {",
            "        if (n < 2) return false;",
            "        if (n == 2 || n == 3) return true;",
            "        if (n % 2 == 0 || n % 3 == 0) return false;",
            "        long sqrtN = (long) Math.sqrt(n) + 1;",
            "        for (long i = 6L; i <= sqrtN; i += 6) {",
            "            if (n % (i - 1) == 0 || n % (i + 1) == 0) return false;",
            "        }",
            "        return true;",
            "    }",
            "",
            "    /* ------- Sieve Of Eratosthenes ---------------- */",
            "    public static List<Integer> sieve(int n) {",
            "        List<Integer> primes = new ArrayList<>();",
            "        boolean[] isPrime = new boolean[n + 1];",
            "        Arrays.fill(isPrime, true);",
            "        isPrime[0] = isPrime[1] = false;",
            "        for (int i = 2; i <= n; i++) {",
            "            if (isPrime[i]) {",
            "                primes.add(i);",
            "                for (int j = 2 * i; j <= n; j += i) {",
            "                    isPrime[j] = false;",
            "                }",
            "            }",
            "        }",
            "        return primes;",
            "    }",
            "",
            "    /* ------ Modular Exponentiation (x^y % mod) ------- */",
            "    static long modPow(long x, long y, long mod) {",
            "        long res = 1;",
            "        while (y > 0) {",
            "            if ((y & 1) == 1) res = (res * x) % mod;",
            "            x = (x * x) % mod;",
            "            y >>= 1;",
            "        }",
            "        return res;",
            "    }",
            "",
            "    static void ruffleSort(int[] a) {",
            "        int n = a.length;",
            "        for (int i = 0; i < n; i++) {",
            "            int oi = random.nextInt(n), temp = a[oi];",
            "            a[oi] = a[i];",
            "            a[i] = temp;",
            "        }",
            "        Arrays.sort(a);",
            "    }",
            "",
            "    public static long gcd(long a, long b) {",
            "        while (b != 0) {",
            "            long temp = b;",
            "            b = a % b;",
            "            a = temp;",
            "        }",
            "        return a;",
            "    }",
            "",
            "    public static void print(int[] arr) {",
            "        for (int x : arr) out.print(x + \" \");",
            "        out.println();",
            "    }",
            "",
            "    public static long add(long a, long b) {",
            "        return (a + b) % mod;",
            "    }",
            "",
            "    public static long sub(long a, long b) {",
            "        return ((a - b) % mod + mod) % mod;",
            "    }",
            "",
            "    static long mul(long a, long b) {",
            "        return (a * b) % mod;",
            "    }",
            "",
            "    static long calPow(long base, long exponent) {",
            "        if (exponent == 0) return 1;",
            "        if (exponent == 1) return base % mod;",
            "        long temp = calPow(base, exponent / 2);",
            "        if (exponent % 2 == 0) return (temp * temp) % mod;",
            "        else return (((temp * temp) % mod) * base) % mod;",
            "    }",
            "",
            "    public static long exp(long base, long exp) {",
            "        if (exp == 0) return 1;",
            "        long half = exp(base, exp / 2);",
            "        if (exp % 2 == 0) return mul(half, half);",
            "        return mul(half, mul(half, base));",
            "    }",
            "",
            "    static long[] factorials = new long[2_000_001];",
            "    static long[] invFactorials = new long[2_000_001];",
            "",
            "    public static void precompFacts() {",
            "        factorials[0] = invFactorials[0] = 1;",
            "        for (int i = 1; i < factorials.length; i++) factorials[i] = mul(factorials[i - 1], i);",
            "        invFactorials[factorials.length - 1] = exp(factorials[factorials.length - 1], mod - 2);",
            "        for (int i = invFactorials.length - 2; i >= 0; i--) invFactorials[i] = mul(invFactorials[i + 1], i + 1);",
            "    }",
            "",
            "    public static long nCk(int n, int k) {",
            "        return mul(factorials[n], mul(invFactorials[k], invFactorials[n - k]));",
            "    }",
            "",
            "    public static void sort(int[] a) {",
            "        ArrayList<Integer> l = new ArrayList<>();",
            "        for (int i : a) l.add(i);",
            "        Collections.sort(l);",
            "        for (int i = 0; i < a.length; i++) a[i] = l.get(i);",
            "    }",
            "",
            "    public static class FastScanner {",
            "        private int BS = 1 << 16;",
            "        private char NC = (char) 0;",
            "        private byte[] buf = new byte[BS];",
            "        private int bId = 0, size = 0;",
            "        private char c = NC;",
            "        private double cnt = 1;",
            "        private BufferedInputStream in;",
            "",
            "        public FastScanner() {",
            "            in = new BufferedInputStream(System.in, BS);",
            "        }",
            "",
            "        public FastScanner(String s) {",
            "            try {",
            "                in = new BufferedInputStream(new FileInputStream(new File(s)), BS);",
            "            } catch (Exception e) {",
            "                in = new BufferedInputStream(System.in, BS);",
            "            }",
            "        }",
            "",
            "        private char getChar() {",
            "            while (bId == size) {",
            "                try {",
            "                    size = in.read(buf);",
            "                } catch (Exception e) {",
            "                    return NC;",
            "                }",
            "                if (size == -1) return NC;",
            "                bId = 0;",
            "            }",
            "            return (char) buf[bId++];",
            "        }",
            "",
            "        public int nextInt() {",
            "            return (int) nextLong();",
            "        }",
            "",
            "        public int[] nextInts(int N) {",
            "            int[] res = new int[N];",
            "            for (int i = 0; i < N; i++) res[i] = (int) nextLong();",
            "            return res;",
            "        }",
            "",
            "        public long[] nextLongs(int N) {",
            "            long[] res = new long[N];",
            "            for (int i = 0; i < N; i++) res[i] = nextLong();",
            "            return res;",
            "        }",
            "",
            "        public long nextLong() {",
            "            cnt = 1;",
            "            boolean neg = false;",
            "            if (c == NC) c = getChar();",
            "            for (; (c < '0' || c > '9'); c = getChar()) {",
            "                if (c == '-') neg = true;",
            "            }",
            "            long res = 0;",
            "            for (; c >= '0' && c <= '9'; c = getChar()) {",
            "                res = (res << 3) + (res << 1) + c - '0';",
            "                cnt *= 10;",
            "            }",
            "            return neg ? -res : res;",
            "        }",
            "",
            "        public double nextDouble() {",
            "            double cur = nextLong();",
            "            return c != '.' ? cur : cur + nextLong() / cnt;",
            "        }",
            "",
            "        public double[] nextDoubles(int N) {",
            "            double[] res = new double[N];",
            "            for (int i = 0; i < N; i++) res[i] = nextDouble();",
            "            return res;",
            "        }",
            "",
            "        public String next() {",
            "            StringBuilder res = new StringBuilder();",
            "            while (c <= 32) c = getChar();",
            "            while (c > 32) {",
            "                res.append(c);",
            "                c = getChar();",
            "            }",
            "            return res.toString();",
            "        }",
            "",
            "        public String nextLine() {",
            "            StringBuilder res = new StringBuilder();",
            "            while (c <= 32) c = getChar();",
            "            while (c != '\\n') {",
            "                res.append(c);",
            "                c = getChar();",
            "            }",
            "            return res.toString();",
            "        }",
            "",
            "        public boolean hasNext() {",
            "            if (c > 32) return true;",
            "            while (true) {",
            "                c = getChar();",
            "                if (c == NC) return false;",
            "                else if (c > 32) return true;",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Java Competitive Programming Template"
    },
    "Template": {
        "prefix": "cp-template",
        "body": [
            "/*",
            " * Author: Aritra Dutta",
            " * Created: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE} ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND} (GMT+5:30)",
            " */",
            "",
            "import java.io.*;",
            "import java.util.*;",
            "",
            "public class Main {",
            "    static class FastReader {",
            "        BufferedReader br;",
            "        StringTokenizer st;",
            "",
            "        public FastReader() {",
            "            br = new BufferedReader(new InputStreamReader(System.in));",
            "        }",
            "",
            "        String next() {",
            "            while (st == null || !st.hasMoreElements()) {",
            "                try {",
            "                    st = new StringTokenizer(br.readLine());",
            "                } catch (IOException e) {",
            "                    e.printStackTrace();",
            "                }",
            "            }",
            "            return st.nextToken();",
            "        }",
            "",
            "        int nextInt() {",
            "            return Integer.parseInt(next());",
            "        }",
            "",
            "        long nextLong() {",
            "            return Long.parseLong(next());",
            "        }",
            "",
            "        double nextDouble() {",
            "            return Double.parseDouble(next());",
            "        }",
            "",
            "        String nextLine() {",
            "            String str = \"\";",
            "            try {",
            "                str = br.readLine();",
            "            } catch (IOException e) {",
            "                e.printStackTrace();",
            "            }",
            "            return str;",
            "        }",
            "    }",
            "",
            "    static FastReader in = new FastReader();",
            "    static PrintWriter out = new PrintWriter(System.out);",
            "",
            "    public static void main(String[] args) {",
            "        int t = in.nextInt();",
            "        while (t-- > 0) {",
            "            solve();",
            "        }",
            "        out.close();",
            "    }",
            "",
            "    static void solve() {",
            "        // Your code here",
            "        $0",
            "    }",
            "}"
        ],
        "description": "Java template for competitive programming"
    },
    "radixsort": {
        "prefix": "radixsort",
        "body": [
            "static int[] radixSort(int[] f){",
            "    int[] to = new int[f.length];",
            "    {",
            "        int[] b = new int[65537];",
            "        for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;",
            "        for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];",
            "        for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];",
            "        int[] d = f; f = to;to = d;",
            "    }",
            "    {",
            "        int[] b = new int[65537];",
            "        for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;",
            "        for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];",
            "        for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];",
            "        int[] d = f; f = to;to = d;",
            "    }",
            "    return f;",
            "}"
        ],
        "description": ""
    },
    "rufflesort": {
        "prefix": "rufflesort",
        "body": [
            "static void ruffleSort(int[] a) {",
            "    int n=a.length;",
            "    Random random = new Random();",
            "    for (int i=0; i<n; i++) {",
            "        int oi=random.nextInt(n);",
            "        int temp=a[oi];",
            "        a[oi]=a[i]; a[i]=temp;",
            "    }",
            "    Arrays.sort(a);",
            "}"
        ],
        "description": ""
    },
    "upperbound": {
        "prefix": "upperbound",
        "body": [
            "static int upper_bound(int arr[],int N, int X){",
            "    int mid;",
            "    int low = 0, high = N;",
            "    while(low<high){",
            "        mid = low + (high - low) / 2;",
            "        if (X >= arr[mid]) {",
            "            low = mid + 1;",
            "        } else {",
            "            high = mid;",
            "        }",
            "    }",
            "    if(low < N && arr[low] <= X) {",
            "        low++;",
            "    }",
            "    return low;",
            "}"
        ],
        "description": ""
    },
    "multiset": {
        "prefix": "multiset",
        "body": [
            "// use TreeMap directly to avoid TLE.",
            "class Multiset { ",
            "    private TreeMap<Integer, Integer> multiset;",
            "    public Multiset() {",
            "        multiset = new TreeMap<>();",
            "    }",
            "    public void add(int element) {",
            "        multiset.put(element, multiset.getOrDefault(element, 0) + 1);",
            "    }",
            "    public void remove(int element) {",
            "        if (multiset.containsKey(element)) {",
            "            int count = multiset.get(element);",
            "            if (count == 1) {",
            "                multiset.remove(element);",
            "            } else {",
            "                multiset.put(element, count - 1);",
            "            }",
            "        }",
            "    }",
            "    public int lower(int element) {",
            "        Map.Entry<Integer, Integer> lowerEntry = multiset.lowerEntry(element);",
            "        return lowerEntry != null ? lowerEntry.getKey() : -1;",
            "    }",
            "    public int higher(int element) {",
            "        Map.Entry<Integer, Integer> higherEntry = multiset.higherEntry(element);",
            "        return higherEntry != null ? higherEntry.getKey() : -1;",
            "    }",
            "    public int floor(int element) {",
            "        Map.Entry<Integer, Integer> lowerEntry = multiset.floorEntry(element);",
            "        return lowerEntry != null ? lowerEntry.getKey() : -1;",
            "    }",
            "    public int ceil(int element) {",
            "        Map.Entry<Integer, Integer> higherEntry = multiset.ceilingEntry(element);",
            "        return higherEntry != null ? higherEntry.getKey() : -1;",
            "    }",
            "    public int size() {",
            "        int length = 0;",
            "        for (int count : multiset.values()) {",
            "            length += count;",
            "        }",
            "        return length;",
            "    }",
            "}",
            ""
        ],
        "description": ""
    },
    "lowerbound": {
        "prefix": "lowerbound",
        "body": [
            "int lower_bound(int arr[], int N, int X){",
            "    int mid,low = 0, high = N;",
            "    while (low < high) {",
            "        mid = low + (high - low) / 2;",
            "        if (X <= arr[mid]) {",
            "            high = mid;",
            "        } else {",
            "            low = mid + 1;",
            "        }",
            "    }",
            "    if(low < N && arr[low] < X) {",
            "        low++;",
            "    }",
            "    return low;",
            "}"
        ],
        "description": ""
    },
    "IO": {
        "prefix": "fastio",
        "body": [
            "class FastIO extends PrintWriter{",
            "    private InputStream stream;private byte[]buf=new byte[1<<16];",
            "    private int curChar,numChars;public FastIO(){this(System.in,System.out);}",
            "    public FastIO(InputStream i,OutputStream o){super(o);stream=i;}",
            "    public FastIO(String i,String o)throws IOException{super(new FileWriter(o));stream=new FileInputStream(i);}",
            "    private int nextByte(){if(numChars==-1)throw new InputMismatchException();if(curChar>=numChars){curChar=0;try{numChars=stream.read(buf);}catch(IOException e){throw new InputMismatchException();}if(numChars==-1)return -1;}return buf[curChar++];}",
            "    public String nextLine(){int c;do{c=nextByte();}while(c<='\\n');StringBuilder res=new StringBuilder();do{res.appendCodePoint(c);c=nextByte();}while(c>'\\n');return res.toString();}",
            "    public String next(){int c;do{c=nextByte();}while(c<=' ');StringBuilder res=new StringBuilder();do{res.appendCodePoint(c);c=nextByte();}while(c>' ');return res.toString();}",
            "    public int nextInt(){int c;do{c=nextByte();}while(c<=' ');int sgn=1;if(c=='-'){sgn=-1;c=nextByte();}int res=0;do{if(c<'0'||c>'9')throw new InputMismatchException();res=10*res+c-'0';c=nextByte();}while(c>' ');return res * sgn;}",
            "    public long nextLong(){int c;do{c=nextByte();}while(c<=' ');long sgn=1;if(c=='-'){sgn=-1;c=nextByte();}long res=0;do{if(c<'0'||c>'9')throw new InputMismatchException();res=10*res+c-'0';c=nextByte();}while(c>' ');return res * sgn;}",
            "    public double nextDouble(){return Double.parseDouble(next());",
            "    }",
            "}"
        ],
        "description": ""
    },
    "mergesort": {
        "prefix": "mergesort",
        "body": [
            "public static void sort(int[]arr){",
            "    if(arr==null){return;}int n=arr.length;if(n<2){return;}",
            "    int mid=n/2;int[]left=new int[mid];int[]right=new int[n - mid];",
            "    System.arraycopy(arr,0,left,0,mid);",
            "    System.arraycopy(arr,mid,right,0,n - mid);",
            "    sort(left);sort(right);merge(arr,left,right);",
            "}",
            "private static void merge(int[]arr,int[]left,int[]right){",
            "    int i=0,j=0,k=0;int leftLength=left.length;",
            "    int rightLength=right.length;while(i<leftLength&&j<rightLength)",
            "    {if(left[i]<=right[j]){arr[k++]=left[i++];}else{arr[k++]=right[j++];}}",
            "        while(i<leftLength){arr[k++]=left[i++];}while(j<rightLength){arr[k++]=right[j++];}",
            "}"
        ],
        "description": ""
    },
    "Pair": {
        "prefix": "pair",
        "body": [
            "static class Pair implements Comparable<Pair>{",
            "    int first, second;",
            "    ",
            "    public Pair(int f, int s){ this.first = f; this.second = s; }",
            "",
            "    @Override",
            "    public int compareTo(Pair o){",
            "        if (this.first!=o.first){ return Integer.compare(this.first, o.first); }",
            "        return Integer.compare(this.second, o.second);",
            "    }",
            "}"
        ],
        "description": ""
    },
    "java-for-loop-i-0-to-n-1": {
        "prefix": "fori0",
        "body": [
            "for (int i = 0; i < n; i++) {",
            "\t$0",
            "}"
        ],
        "description": "Create a for loop with 'i' ranging from 0 to n-1"
    },
    "java-for-loop-i-1-to-n": {
        "prefix": "fori1",
        "body": [
            "for (int i = 1; i <= n; i++) {",
            "\t$0",
            "}"
        ],
        "description": "Create a for loop with 'i' ranging from 1 to n"
    },
    "java-for-loop-j-0-to-n-1": {
        "prefix": "forj0",
        "body": [
            "for (int j = 0; j < n; j++) {",
            "\t$0",
            "}"
        ],
        "description": "Create a for loop with 'j' ranging from 0 to n-1"
    },
    "java-for-loop-j-1-to-n": {
        "prefix": "forj1",
        "body": [
            "for (int j = 1; j <= n; j++) {",
            "\t$0",
            "}"
        ],
        "description": "Create a for loop with 'j' ranging from 1 to n"
    },
    "java-for-loop-k-0-to-n-1": {
        "prefix": "fork0",
        "body": [
            "for (int k = 0; k < n; k++) {",
            "\t$0",
            "}"
        ],
        "description": "Create a for loop with 'k' ranging from 0 to n-1"
    },
    "java-for-loop-k-1-to-n": {
        "prefix": "fork1",
        "body": [
            "for (int k = 1; k <= n; k++) {",
            "\t$0",
            "}"
        ],
        "description": "Create a for loop with 'k' ranging from 1 to n"
    },
    "java-reverse-for-loop-i-n-1-to-0": {
        "prefix": "rfori0",
        "body": [
            "for (int i = n - 1; i >= 0; i--) {",
            "\t$0",
            "}"
        ],
        "description": "Create a reverse for loop with 'i' ranging from n-1 to 0"
    },
    "java-reverse-for-loop-i-n-to-1": {
        "prefix": "rfori1",
        "body": [
            "for (int i = n; i >= 1; i--) {",
            "\t$0",
            "}"
        ],
        "description": "Create a reverse for loop with 'i' ranging from n to 1"
    },
    "java-reverse-for-loop-j-n-1-to-0": {
        "prefix": "rforj0",
        "body": [
            "for (int j = n - 1; j >= 0; j--) {",
            "\t$0",
            "}"
        ],
        "description": "Create a reverse for loop with 'j' ranging from n-1 to 0"
    },
    "java-reverse-for-loop-j-n-to-1": {
        "prefix": "rforj1",
        "body": [
            "for (int j = n; j >= 1; j--) {",
            "\t$0",
            "}"
        ],
        "description": "Create a reverse for loop with 'j' ranging from n to 1"
    },
    "java-reverse-for-loop-k-n-1-to-0": {
        "prefix": "rfork0",
        "body": [
            "for (int k = n - 1; k >= 0; k--) {",
            "\t$0",
            "}"
        ],
        "description": "Create a reverse for loop with 'k' ranging from n-1 to 0"
    },
    "java-reverse-for-loop-k-n-to-1": {
        "prefix": "rfork1",
        "body": [
            "for (int k = n; k >= 1; k--) {",
            "\t$0",
            "}"
        ],
        "description": "Create a reverse for loop with 'k' ranging from n to 1"
    },
    "Dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "static int[] dijkstra(List<List<int[]>> graph, int source) {",
            "    int n = graph.size();",
            "    int[] dist = new int[n];",
            "    Arrays.fill(dist, Integer.MAX_VALUE);",
            "    dist[source] = 0;",
            "    PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));",
            "    pq.add(new int[]{source, 0});",
            "    while (!pq.isEmpty()) {",
            "        int[] node = pq.poll();",
            "        int u = node[0], d = node[1];",
            "        if (d > dist[u]) continue;",
            "        for (int[] edge : graph.get(u)) {",
            "            int v = edge[0], w = edge[1];",
            "            if (dist[u] + w < dist[v]) {",
            "                dist[v] = dist[u] + w;",
            "                pq.add(new int[]{v, dist[v]});",
            "            }",
            "        }",
            "    }",
            "    return dist;",
            "}"
        ],
        "description": "Dijkstra's Algorithm"
    },
    "BellmanFord": {
        "prefix": "bellmanford",
        "body": [
            "static int[] bellmanFord(List<int[]> edges, int n, int source) {",
            "    int[] dist = new int[n];",
            "    Arrays.fill(dist, Integer.MAX_VALUE);",
            "    dist[source] = 0;",
            "    for (int i = 0; i < n - 1; i++) {",
            "        for (int[] edge : edges) {",
            "            int u = edge[0], v = edge[1], w = edge[2];",
            "            if (dist[u] != Integer.MAX_VALUE && dist[u] + w < dist[v]) {",
            "                dist[v] = dist[u] + w;",
            "            }",
            "        }",
            "    }",
            "    // Check for negative cycles",
            "    for (int[] edge : edges) {",
            "        int u = edge[0], v = edge[1], w = edge[2];",
            "        if (dist[u] != Integer.MAX_VALUE && dist[u] + w < dist[v]) {",
            "            throw new RuntimeException(\"Negative cycle detected\");",
            "        }",
            "    }",
            "    return dist;",
            "}"
        ],
        "description": "Bellman-Ford Algorithm"
    },
    "FloydWarshall": {
        "prefix": "floydwarshall",
        "body": [
            "static int[][] floydWarshall(int[][] graph) {",
            "    int n = graph.length;",
            "    int[][] dist = new int[n][n];",
            "    for (int i = 0; i < n; i++) {",
            "        for (int j = 0; j < n; j++) {",
            "            dist[i][j] = graph[i][j];",
            "        }",
            "    }",
            "    for (int k = 0; k < n; k++) {",
            "        for (int i = 0; i < n; i++) {",
            "            for (int j = 0; j < n; j++) {",
            "                if (dist[i][k] != Integer.MAX_VALUE && dist[k][j] != Integer.MAX_VALUE) {",
            "                    dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);",
            "                }",
            "            }",
            "        }",
            "    }",
            "    return dist;",
            "}"
        ],
        "description": "Floyd-Warshall Algorithm"
    },
    "Sieve": {
        "prefix": "sieve",
        "body": [
            "static List<Integer> sieve(int n) {",
            "    boolean[] isPrime = new boolean[n + 1];",
            "    Arrays.fill(isPrime, true);",
            "    List<Integer> primes = new ArrayList<>();",
            "    for (int p = 2; p * p <= n; p++) {",
            "        if (isPrime[p]) {",
            "            for (int i = p * p; i <= n; i += p) {",
            "                isPrime[i] = false;",
            "            }",
            "        }",
            "    }",
            "    for (int p = 2; p <= n; p++) {",
            "        if (isPrime[p]) primes.add(p);",
            "    }",
            "    return primes;",
            "}"
        ],
        "description": "Sieve of Eratosthenes"
    },
    "GCDLCM": {
        "prefix": "gcdlcm",
        "body": [
            "static int gcd(int a, int b) {",
            "    return b == 0 ? a : gcd(b, a % b);",
            "}",
            "",
            "static int lcm(int a, int b) {",
            "    return a * (b / gcd(a, b));",
            "}"
        ],
        "description": "GCD and LCM"
    },
    "SegmentTree": {
        "prefix": "segmenttree",
        "body": [
            "static class SegmentTree {",
            "    int[] tree;",
            "    int[] lazy;",
            "    int n;",
            "",
            "    SegmentTree(int[] arr) {",
            "        n = arr.length;",
            "        tree = new int[4 * n];",
            "        lazy = new int[4 * n];",
            "        build(arr, 1, 0, n - 1);",
            "    }",
            "",
            "    void build(int[] arr, int node, int start, int end) {",
            "        if (start == end) {",
            "            tree[node] = arr[start];",
            "        } else {",
            "            int mid = (start + end) / 2;",
            "            build(arr, 2 * node, start, mid);",
            "            build(arr, 2 * node + 1, mid + 1, end);",
            "            tree[node] = tree[2 * node] + tree[2 * node + 1];",
            "        }",
            "    }",
            "",
            "    void propagate(int node, int start, int end) {",
            "        if (lazy[node] != 0) {",
            "            tree[node] += lazy[node] * (end - start + 1);",
            "            if (start != end) {",
            "                lazy[2 * node] += lazy[node];",
            "                lazy[2 * node + 1] += lazy[node];",
            "            }",
            "            lazy[node] = 0;",
            "        }",
            "    }",
            "",
            "    void update(int node, int start, int end, int l, int r, int val) {",
            "        propagate(node, start, end);",
            "        if (start > r || end < l) return;",
            "        if (start >= l && end <= r) {",
            "            lazy[node] += val;",
            "            propagate(node, start, end);",
            "            return;",
            "        }",
            "        int mid = (start + end) / 2;",
            "        update(2 * node, start, mid, l, r, val);",
            "        update(2 * node + 1, mid + 1, end, l, r, val);",
            "        tree[node] = tree[2 * node] + tree[2 * node + 1];",
            "    }",
            "",
            "    int query(int node, int start, int end, int l, int r) {",
            "        propagate(node, start, end);",
            "        if (start > r || end < l) return 0;",
            "        if (start >= l && end <= r) return tree[node];",
            "        int mid = (start + end) / 2;",
            "        return query(2 * node, start, mid, l, r) + query(2 * node + 1, mid + 1, end, l, r);",
            "    }",
            "}"
        ],
        "description": "Segment Tree with Lazy Propagation"
    },
    "FenwickTree": {
        "prefix": "fenwicktree",
        "body": [
            "static class FenwickTree {",
            "    int[] tree;",
            "    int n;",
            "",
            "    FenwickTree(int size) {",
            "        n = size;",
            "        tree = new int[n + 1];",
            "    }",
            "",
            "    void update(int idx, int val) {",
            "        while (idx <= n) {",
            "            tree[idx] += val;",
            "            idx += idx & -idx;",
            "        }",
            "    }",
            "",
            "    int query(int idx) {",
            "        int sum = 0;",
            "        while (idx > 0) {",
            "            sum += tree[idx];",
            "            idx -= idx & -idx;",
            "        }",
            "        return sum;",
            "    }",
            "",
            "    int query(int l, int r) {",
            "        return query(r) - query(l - 1);",
            "    }",
            "}"
        ],
        "description": "Fenwick Tree (Binary Indexed Tree)"
    },
    "DSU": {
        "prefix": "dsu",
        "body": [
            "static class DSU {",
            "    int[] parent;",
            "    int[] rank;",
            "",
            "    DSU(int n) {",
            "        parent = new int[n];",
            "        rank = new int[n];",
            "        for (int i = 0; i < n; i++) parent[i] = i;",
            "    }",
            "",
            "    int find(int x) {",
            "        if (parent[x] != x) parent[x] = find(parent[x]);",
            "        return parent[x];",
            "    }",
            "",
            "    void union(int x, int y) {",
            "        int xRoot = find(x), yRoot = find(y);",
            "        if (xRoot == yRoot) return;",
            "        if (rank[xRoot] < rank[yRoot]) parent[xRoot] = yRoot;",
            "        else if (rank[xRoot] > rank[yRoot]) parent[yRoot] = xRoot;",
            "        else {",
            "            parent[yRoot] = xRoot;",
            "            rank[xRoot]++;",
            "        }",
            "    }",
            "}"
        ],
        "description": "Disjoint Set Union (DSU)"
    },
    "BinaryExponentiation": {
        "prefix": "binpow",
        "body": [
            "static long binpow(long a, long b, long mod) {",
            "    long res = 1;",
            "    while (b > 0) {",
            "        if ((b & 1) == 1) res = res * a % mod;",
            "        a = a * a % mod;",
            "        b >>= 1;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Binary Exponentiation"
    },
    "Treap": {
        "prefix": "treap",
        "body": [
            "static class Treap {",
            "    static class Node {",
            "        int key, priority, size;",
            "        Node left, right;",
            "        Node(int key) {",
            "            this.key = key;",
            "            this.priority = new Random().nextInt();",
            "            this.size = 1;",
            "        }",
            "    }",
            "",
            "    static int size(Node node) {",
            "        return node == null ? 0 : node.size;",
            "    }",
            "",
            "    static void updateSize(Node node) {",
            "        if (node != null) node.size = size(node.left) + size(node.right) + 1;",
            "    }",
            "",
            "    static Node[] split(Node root, int key) {",
            "        if (root == null) return new Node[]{null, null};",
            "        if (root.key < key) {",
            "            Node[] splitRight = split(root.right, key);",
            "            root.right = splitRight[0];",
            "            updateSize(root);",
            "            return new Node[]{root, splitRight[1]};",
            "        } else {",
            "            Node[] splitLeft = split(root.left, key);",
            "            root.left = splitLeft[1];",
            "            updateSize(root);",
            "            return new Node[]{splitLeft[0], root};",
            "        }",
            "    }",
            "",
            "    static Node merge(Node left, Node right) {",
            "        if (left == null) return right;",
            "        if (right == null) return left;",
            "        if (left.priority > right.priority) {",
            "            left.right = merge(left.right, right);",
            "            updateSize(left);",
            "            return left;",
            "        } else {",
            "            right.left = merge(left, right.left);",
            "            updateSize(right);",
            "            return right;",
            "        }",
            "    }",
            "",
            "    static Node insert(Node root, int key) {",
            "        Node[] split = split(root, key);",
            "        return merge(merge(split[0], new Node(key)), split[1]);",
            "    }",
            "",
            "    static Node erase(Node root, int key) {",
            "        Node[] split = split(root, key);",
            "        return merge(split[0], split(split[1], key + 1)[1]);",
            "    }",
            "}"
        ],
        "description": "Treap (Randomized Binary Search Tree)"
    },
    "LiChaoTree": {
        "prefix": "lichaotree",
        "body": [
            "static class LiChaoTree {",
            "    static class Line {",
            "        long m, b;",
            "        Line(long m, long b) { this.m = m; this.b = b; }",
            "        long eval(long x) { return m * x + b; }",
            "    }",
            "",
            "    Line[] tree;",
            "    int size;",
            "",
            "    LiChaoTree(int size) {",
            "        this.size = size;",
            "        tree = new Line[4 * size];",
            "    }",
            "",
            "    void addLine(Line line, int node, int left, int right) {",
            "        if (tree[node] == null) {",
            "            tree[node] = line;",
            "            return;",
            "        }",
            "        int mid = (left + right) / 2;",
            "        boolean dominateLeft = line.eval(left) < tree[node].eval(left);",
            "        boolean dominateMid = line.eval(mid) < tree[node].eval(mid);",
            "        if (dominateMid) {",
            "            Line temp = tree[node];",
            "            tree[node] = line;",
            "            line = temp;",
            "        }",
            "        if (dominateLeft != dominateMid) {",
            "            addLine(line, 2 * node, left, mid);",
            "        } else {",
            "            addLine(line, 2 * node + 1, mid + 1, right);",
            "        }",
            "    }",
            "",
            "    long query(long x, int node, int left, int right) {",
            "        long res = tree[node] == null ? Long.MAX_VALUE : tree[node].eval(x);",
            "        if (left == right) return res;",
            "        int mid = (left + right) / 2;",
            "        if (x <= mid) {",
            "            return Math.min(res, query(x, 2 * node, left, mid));",
            "        } else {",
            "            return Math.min(res, query(x, 2 * node + 1, mid + 1, right));",
            "        }",
            "    }",
            "}"
        ],
        "description": "Li Chao Tree (Dynamic Convex Hull)"
    },
    "ConvexHullTrick": {
        "prefix": "cht",
        "body": [
            "static class ConvexHullTrick {",
            "    static class Line {",
            "        long m, b;",
            "        Line(long m, long b) { this.m = m; this.b = b; }",
            "        long eval(long x) { return m * x + b; }",
            "    }",
            "",
            "    Deque<Line> dq = new ArrayDeque<>();",
            "",
            "    boolean isBad(Line l1, Line l2, Line l3) {",
            "        return (l3.b - l1.b) * (l1.m - l2.m) <= (l2.b - l1.b) * (l1.m - l3.m);",
            "    }",
            "",
            "    void addLine(long m, long b) {",
            "        Line newLine = new Line(m, b);",
            "        while (dq.size() >= 2 && isBad(dq.get(dq.size() - 2), dq.getLast(), newLine)) {",
            "            dq.pollLast();",
            "        }",
            "        dq.addLast(newLine);",
            "    }",
            "",
            "    long query(long x) {",
            "        while (dq.size() >= 2 && dq.getFirst().eval(x) >= dq.get(1).eval(x)) {",
            "            dq.pollFirst();",
            "        }",
            "        return dq.getFirst().eval(x);",
            "    }",
            "}"
        ],
        "description": "Convex Hull Trick"
    },
    "MatrixOperations": {
        "prefix": "matrix",
        "body": [
            "static long[][] matrixMultiply(long[][] a, long[][] b, long mod) {",
            "    int n = a.length;",
            "    long[][] res = new long[n][n];",
            "    for (int i = 0; i < n; i++) {",
            "        for (int j = 0; j < n; j++) {",
            "            for (int k = 0; k < n; k++) {",
            "                res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % mod;",
            "            }",
            "        }",
            "    }",
            "    return res;",
            "}",
            "",
            "static long[][] matrixPower(long[][] a, long p, long mod) {",
            "    int n = a.length;",
            "    long[][] res = new long[n][n];",
            "    for (int i = 0; i < n; i++) res[i][i] = 1;",
            "    while (p > 0) {",
            "        if ((p & 1) == 1) res = matrixMultiply(res, a, mod);",
            "        a = matrixMultiply(a, a, mod);",
            "        p >>= 1;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Matrix Multiplication and Exponentiation"
    },
    "MaxFlowDinic": {
        "prefix": "dinic",
        "body": [
            "static class Dinic {",
            "    static class Edge {",
            "        int to, rev, cap, flow;",
            "        Edge(int to, int rev, int cap) {",
            "            this.to = to;",
            "            this.rev = rev;",
            "            this.cap = cap;",
            "        }",
            "    }",
            "",
            "    List<Edge>[] graph;",
            "    int[] level, ptr;",
            "    int n;",
            "",
            "    Dinic(int n) {",
            "        this.n = n;",
            "        graph = new ArrayList[n];",
            "        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();",
            "    }",
            "",
            "    void addEdge(int u, int v, int cap) {",
            "        graph[u].add(new Edge(v, graph[v].size(), cap));",
            "        graph[v].add(new Edge(u, graph[u].size() - 1, 0));",
            "    }",
            "",
            "    boolean bfs(int s, int t) {",
            "        level = new int[n];",
            "        Arrays.fill(level, -1);",
            "        level[s] = 0;",
            "        Queue<Integer> q = new LinkedList<>();",
            "        q.add(s);",
            "        while (!q.isEmpty()) {",
            "            int u = q.poll();",
            "            for (Edge e : graph[u]) {",
            "                if (level[e.to] == -1 && e.flow < e.cap) {",
            "                    level[e.to] = level[u] + 1;",
            "                    q.add(e.to);",
            "                }",
            "            }",
            "        }",
            "        return level[t] != -1;",
            "    }",
            "",
            "    int dfs(int u, int t, int flow) {",
            "        if (u == t) return flow;",
            "        for (; ptr[u] < graph[u].size(); ptr[u]++) {",
            "            Edge e = graph[u].get(ptr[u]);",
            "            if (level[e.to] == level[u] + 1 && e.flow < e.cap) {",
            "                int pushed = dfs(e.to, t, Math.min(flow, e.cap - e.flow));",
            "                if (pushed > 0) {",
            "                    e.flow += pushed;",
            "                    graph[e.to].get(e.rev).flow -= pushed;",
            "                    return pushed;",
            "                }",
            "            }",
            "        }",
            "        return 0;",
            "    }",
            "",
            "    int maxFlow(int s, int t) {",
            "        int flow = 0;",
            "        while (bfs(s, t)) {",
            "            ptr = new int[n];",
            "            while (true) {",
            "                int pushed = dfs(s, t, Integer.MAX_VALUE);",
            "                if (pushed == 0) break;",
            "                flow += pushed;",
            "            }",
            "        }",
            "        return flow;",
            "    }",
            "}"
        ],
        "description": "Dinic's Algorithm for Max Flow"
    },
    "Kosaraju": {
        "prefix": "kosaraju",
        "body": [
            "static class Kosaraju {",
            "    List<Integer>[] graph, reverseGraph;",
            "    boolean[] visited;",
            "    Stack<Integer> stack;",
            "    List<List<Integer>> sccs;",
            "",
            "    Kosaraju(int n) {",
            "        graph = new ArrayList[n];",
            "        reverseGraph = new ArrayList[n];",
            "        for (int i = 0; i < n; i++) {",
            "            graph[i] = new ArrayList<>();",
            "            reverseGraph[i] = new ArrayList<>();",
            "        }",
            "    }",
            "",
            "    void addEdge(int u, int v) {",
            "        graph[u].add(v);",
            "        reverseGraph[v].add(u);",
            "    }",
            "",
            "    void dfs(int u) {",
            "        visited[u] = true;",
            "        for (int v : graph[u]) {",
            "            if (!visited[v]) dfs(v);",
            "        }",
            "        stack.push(u);",
            "    }",
            "",
            "    void reverseDfs(int u, List<Integer> component) {",
            "        visited[u] = true;",
            "        component.add(u);",
            "        for (int v : reverseGraph[u]) {",
            "            if (!visited[v]) reverseDfs(v, component);",
            "        }",
            "    }",
            "",
            "    List<List<Integer>> getSCCs() {",
            "        int n = graph.length;",
            "        visited = new boolean[n];",
            "        stack = new Stack<>();",
            "        for (int i = 0; i < n; i++) {",
            "            if (!visited[i]) dfs(i);",
            "        }",
            "        Arrays.fill(visited, false);",
            "        sccs = new ArrayList<>();",
            "        while (!stack.isEmpty()) {",
            "            int u = stack.pop();",
            "            if (!visited[u]) {",
            "                List<Integer> component = new ArrayList<>();",
            "                reverseDfs(u, component);",
            "                sccs.add(component);",
            "            }",
            "        }",
            "        return sccs;",
            "    }",
            "}"
        ],
        "description": "Kosaraju's Algorithm for Strongly Connected Components"
    },
    "Tarjan": {
        "prefix": "tarjan",
        "body": [
            "static class Tarjan {",
            "    List<Integer>[] graph;",
            "    int[] disc, low;",
            "    boolean[] inStack;",
            "    Stack<Integer> stack;",
            "    List<List<Integer>> sccs;",
            "    int time;",
            "",
            "    Tarjan(int n) {",
            "        graph = new ArrayList[n];",
            "        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();",
            "    }",
            "",
            "    void addEdge(int u, int v) {",
            "        graph[u].add(v);",
            "    }",
            "",
            "    void dfs(int u) {",
            "        disc[u] = low[u] = ++time;",
            "        stack.push(u);",
            "        inStack[u] = true;",
            "        for (int v : graph[u]) {",
            "            if (disc[v] == -1) {",
            "                dfs(v);",
            "                low[u] = Math.min(low[u], low[v]);",
            "            } else if (inStack[v]) {",
            "                low[u] = Math.min(low[u], disc[v]);",
            "            }",
            "        }",
            "        if (low[u] == disc[u]) {",
            "            List<Integer> component = new ArrayList<>();",
            "            while (true) {",
            "                int v = stack.pop();",
            "                inStack[v] = false;",
            "                component.add(v);",
            "                if (u == v) break;",
            "            }",
            "            sccs.add(component);",
            "        }",
            "    }",
            "",
            "    List<List<Integer>> getSCCs() {",
            "        int n = graph.length;",
            "        disc = new int[n];",
            "        low = new int[n];",
            "        inStack = new boolean[n];",
            "        stack = new Stack<>();",
            "        sccs = new ArrayList<>();",
            "        time = 0;",
            "        Arrays.fill(disc, -1);",
            "        for (int i = 0; i < n; i++) {",
            "            if (disc[i] == -1) dfs(i);",
            "        }",
            "        return sccs;",
            "    }",
            "}"
        ],
        "description": "Tarjan's Algorithm for Strongly Connected Components"
    },
    "BFS": {
        "prefix": "bfs",
        "body": [
            "static void bfs(List<List<Integer>> graph, int start) {",
            "    int n = graph.size();",
            "    boolean[] visited = new boolean[n];",
            "    Queue<Integer> queue = new LinkedList<>();",
            "    queue.add(start);",
            "    visited[start] = true;",
            "",
            "    while (!queue.isEmpty()) {",
            "        int u = queue.poll();",
            "        // Process node u here",
            "        for (int v : graph.get(u)) {",
            "            if (!visited[v]) {",
            "                visited[v] = true;",
            "                queue.add(v);",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Breadth-First Search (BFS) for a graph"
    },
    "DFS": {
        "prefix": "dfs",
        "body": [
            "static void dfs(List<List<Integer>> graph, int u, boolean[] visited) {",
            "    visited[u] = true;",
            "    // Process node u here",
            "    for (int v : graph.get(u)) {",
            "        if (!visited[v]) {",
            "            dfs(graph, v, visited);",
            "        }",
            "    }",
            "}"
        ],
        "description": "Depth-First Search (DFS) for a graph"
    }
}